/* GUIDES */
create type public.guide_difficulty as enum ('easy', 'medium', 'hard');
create type public.guide_duration as enum ('short', 'medium', 'long');
create table public.guides (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	title text not null,
	description text not null,
	image text not null,
	tags text [] not null,
	difficulty public.guide_difficulty not null,
	duration public.guide_duration not null,
	steps jsonb [] not null
);
alter table public.guides
add column fts tsvector generated always as (
		to_tsvector('simple', title || ' ' || description)
	) stored;
create index guides_fts on public.guides using gin (fts);
create trigger handle_updated_at before
update on public.guides for each row execute procedure moddatetime (updated_at);
create table public.guides_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	guide_id bigint references public.guides on delete cascade not null,
	user_id uuid references public.profiles not null,
	status public.moderation_status not null,
	comment text not null
);
create function public.handle_guide_moderation_updates() returns trigger language plpgsql security definer as $$ begin
insert into public.guides_moderation (guide_id, user_id, status, comment)
values (
		new.id,
		new.user_id,
		'pending'::moderation_status,
		'Pending moderation'
	);
return new;
end;
$$;
create trigger on_guides_insert
after
insert on public.guides for each row execute procedure public.handle_guide_moderation_updates();
create trigger on_guides_update
after
update on public.guides for each row execute procedure public.handle_guide_moderation_updates();
create table public.guides_useful(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	guide_id bigint references public.guides not null,
	unique (user_id, guide_id)
);
create function public.get_guide_useful_count(guide_id bigint, user_id uuid default null) returns table (count bigint, has_useful boolean) language sql security definer as $$
select count(*) as count,
	case
		when exists (
			select 1
			from public.guides_useful
			where user_id = $2
				and guide_id = $1
		) then true
		else false
	end as has_useful
from public.guides_useful
where guide_id = $1;
$$;
create table public.guides_bookmark(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	guide_id bigint references public.guides not null,
	unique (user_id, guide_id)
);
create function public.get_guide_bookmark(guide_id bigint, user_id uuid default null) returns table (has_bookmark boolean) language sql security definer as $$
select exists (
	select 1
	from public.guides_bookmark
	where user_id = $2
		and guide_id = $1
) as has_bookmark;
$$;
create view public.latest_guides_moderation with (security_invoker = on) as
select distinct on (guide_id) *
from public.guides_moderation
order by guide_id,
	inserted_at desc;
create view public.guides_view with (security_invoker = on) as
select h.*,
	m.status as moderation_status
from public.guides h
	left join public.latest_guides_moderation m on h.id = m.guide_id;
create view public.guides_tags with (security_invoker = on) as
select unnest(tags) as tag,
	count(*) as count
from public.guides
group by tag;
create function public.get_guides_ordered_by_useful(
    sort_order text default 'desc',
    search text default '',
    tag_filters text[] default '{}',
    user_id uuid default null,
    filter_liked boolean default false,
    filter_bookmarked boolean default false
) 
returns setof public.guides_view 
language sql 
security definer 
as $$
with filtered_guides as (
    select g.*
    from public.guides_view g
    where 
        (search = '' OR g.title ILIKE '%' || search || '%')
        and (array_length(tag_filters, 1) is null OR g.tags && tag_filters)
        and (
            not filter_liked 
            or exists (
                select 1 
                from public.guides_useful gu 
                where gu.guide_id = g.id 
                and gu.user_id = user_id
            )
        )
        and (
            not filter_bookmarked 
            or exists (
                select 1 
                from public.guides_bookmark gb 
                where gb.guide_id = g.id 
                and gb.user_id = user_id
            )
        )
)
select g.*
from filtered_guides g
left join (
    select guide_id, count(*) as usefuls_count
    from public.guides_useful
    group by guide_id
) usefuls on g.id = usefuls.guide_id
order by 
    case when sort_order = 'asc' then coalesce(usefuls.usefuls_count, 0) end asc,
    case when sort_order = 'desc' then coalesce(usefuls.usefuls_count, 0) end desc;
$$;
-- Storage Buckets
-- insert into storage.buckets (id, name, public, allowed_mime_types)
-- values ('guides', 'Guides', true, '{"image/*"}');
-- RLS policies
alter table public.guides enable row level security;
alter table public.guides_moderation enable row level security;
alter table public.guides_useful enable row level security;
create policy "Allow users to read approved guides" on public.guides for
select using (
		exists (
			select 1
			from public.guides_moderation
			where guide_id = guides.id
				and status = 'approved'::public.moderation_status
		)
	);
create policy "Allow users to read their own guides" on public.guides for
select using (auth.uid() = user_id);
create policy "Allow users to create their own guides" on public.guides for
insert with check (
		(
			select authorize('guides.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to update their own guides" on public.guides for
update using (
		(
			select authorize('guides.update')
		)
		and auth.uid() = user_id
	) with check (auth.uid() = user_id);
create policy "Allow users to delete their own guides" on public.guides for delete using (
	(
		select authorize('guides.delete')
	)
	and auth.uid() = user_id
);
create policy "Allow moderators read all guides" on public.guides for
select using (
		(
			select authorize('guides.moderate')
		)
	);
create policy "Allow moderators update all guides" on public.guides for
update using (
		(
			select authorize('guides.moderate')
		)
	);
create policy "Allow moderators delete all guides" on public.guides for delete using (
	(
		select authorize('guides.moderate')
	)
);
create policy "Allow users to read approved guides moderation" on public.guides_moderation for
select using (
		status = 'approved'::public.moderation_status
	);
create policy "Allow users to read their own guides moderation" on public.guides_moderation for
select using (auth.uid() = user_id);
create policy "Allow moderators to read all guides moderation" on public.guides_moderation for
select using (
		(
			select authorize('guides.moderate')
		)
	);
create policy "Allow moderators to insert guides moderation" on public.guides_moderation for
insert with check (
		(
			select authorize('guides.moderate')
		)
	);
create policy "Allow users to read their own guides useful" on public.guides_useful for
select using (auth.uid() = user_id);
create policy "Allow users to create their own guides useful" on public.guides_useful for
insert with check (
		(
			select authorize('guides.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to delete their own guides useful" on public.guides_useful for delete using (
	(
		select authorize('guides.delete')
	)
	and auth.uid() = user_id
);
create policy "Allow users to read their own guides bookmark" on public.guides_bookmark for
select using (auth.uid() = user_id);
create policy "Allow users to create their own guides bookmark" on public.guides_bookmark for
insert with check (
		(
			select authorize('guides.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to delete their own guides bookmark" on public.guides_bookmark for delete using (
	(
		select authorize('guides.delete')
	)
	and auth.uid() = user_id
);
create policy "Allow users to upload images for their guides" on storage.objects for
insert to authenticated with check (bucket_id = 'guides');